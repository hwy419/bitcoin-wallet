/**
 * ReceiveScreen Component Test Suite
 *
 * Comprehensive tests for the ReceiveScreen component covering:
 * - Initial render and loading states
 * - QR code generation
 * - Address display and copying
 * - Auto-generation of addresses for privacy
 * - Multisig account handling
 * - Address list display
 * - Privacy features (used/unused addresses)
 * - Error handling
 * - User interactions
 *
 * Total Tests: 35
 * Priority: P1 - Core user flow
 */

import React from 'react';
import { screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { renderWithProviders, userEvent, mockChromeSendMessageAsync, mockClipboard } from './testUtils';
import ReceiveScreen from '../ReceiveScreen';
import { createMockAccount, createMockMultisigAccount, createMockAddress } from './testFactories';
import { MessageType } from '../../../shared/types';
import QRCode from 'qrcode';

// Mock QRCode library
jest.mock('qrcode');

describe('ReceiveScreen', () => {
  const mockOnBack = jest.fn();
  let mockAccount: ReturnType<typeof createMockAccount>;
  let mockMultisigAccount: ReturnType<typeof createMockMultisigAccount>;
  let clipboard: ReturnType<typeof mockClipboard>;

  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();

    // Create mock accounts
    mockAccount = createMockAccount({
      name: 'Test Account',
      addresses: [
        createMockAddress({
          address: 'tb1qreceive0123456789abcdefghijklm',
          index: 0,
          isChange: false,
          used: true,
        }),
        createMockAddress({
          address: 'tb1qreceive1123456789abcdefghijklm',
          index: 1,
          isChange: false,
          used: false,
        }),
      ],
    });

    mockMultisigAccount = createMockMultisigAccount({
      name: 'Test Multisig',
    });

    // Mock clipboard
    clipboard = mockClipboard();

    // Mock QRCode.toCanvas
    (QRCode.toCanvas as jest.Mock).mockImplementation((canvas, text, options, callback) => {
      if (callback) {
        callback(null); // Success
      }
    });
  });

  afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
  });

  describe('Initial Render - Single-sig Account', () => {
    it('renders header with account name in tab mode', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qnewaddress123',
          derivationPath: "m/84'/1'/0'/0/2",
          index: 2,
          isChange: false,
          used: false,
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={false} />
      );

      // Wait for PrivacyProvider to initialize and component to render
      await waitFor(() => {
        expect(screen.getByText('Receive Bitcoin')).toBeInTheDocument();
      });
      expect(screen.getByText('Test Account')).toBeInTheDocument();
    });

    it('does not render header in modal mode', () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={true} />
      );

      expect(screen.queryByText('Receive Bitcoin')).not.toBeInTheDocument();
    });

    it('displays the most recent receiving address', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        // Should show the most recent (last) receiving address - check in main QR code section
        const addresses = screen.getAllByText('tb1qreceive1123456789abcdefghijklm');
        expect(addresses.length).toBeGreaterThan(0);
      });
    });

    it('generates QR code for current address', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(QRCode.toCanvas).toHaveBeenCalledWith(
          expect.any(Object), // canvas ref
          'tb1qreceive1123456789abcdefghijklm',
          expect.objectContaining({
            width: 240,
            margin: 2,
          }),
          expect.any(Function)
        );
      });
    });
  });

  describe('Auto-generate Address for Privacy', () => {
    it('auto-generates new address on mount for single-sig', async () => {
      const sendMessage = mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qautogenerated123456789abcdefg',
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(sendMessage).toHaveBeenCalledWith({
          type: MessageType.GENERATE_ADDRESS,
          payload: {
            accountIndex: mockAccount.index,
            isChange: false,
          },
        });
      });
    });

    it('shows privacy banner after auto-generating address', async () => {
      // Use real timers for this test since we need async operations to complete
      jest.useRealTimers();

      const sendMessage = mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qautogenerated123',
          derivationPath: "m/84'/1'/0'/0/2",
          index: 2,
          isChange: false,
          used: false,
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      // First wait for the GENERATE_ADDRESS message to be called
      await waitFor(() => {
        expect(sendMessage).toHaveBeenCalledWith(
          expect.objectContaining({
            type: MessageType.GENERATE_ADDRESS,
            payload: expect.any(Object),
          })
        );
      }, { timeout: 3000 });

      // Then wait for the privacy banner to appear (after async address generation completes)
      await waitFor(() => {
        expect(screen.getByText(/Fresh Address Generated/i)).toBeInTheDocument();
      }, { timeout: 3000 });

      expect(screen.getByText(/New address generated for privacy/i)).toBeInTheDocument();

      // Restore fake timers for other tests
      jest.useFakeTimers();
    });

    it('auto-dismisses privacy banner after 3 seconds', async () => {
      // Use real timers initially to let the component mount and show the banner
      jest.useRealTimers();

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qautogenerated123',
          derivationPath: "m/84'/1'/0'/0/2",
          index: 2,
          isChange: false,
          used: false,
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      // Wait for banner to appear
      await waitFor(() => {
        expect(screen.getByText(/Fresh Address Generated/i)).toBeInTheDocument();
      }, { timeout: 3000 });

      // Now wait for the real timeout to dismiss the banner (3 seconds)
      await waitFor(() => {
        expect(screen.queryByText(/Fresh Address Generated/i)).not.toBeInTheDocument();
      }, { timeout: 4000 });

      // Restore fake timers for other tests
      jest.useFakeTimers();
    });

    it('does NOT auto-generate address for multisig accounts', async () => {
      const sendMessage = mockChromeSendMessageAsync({});

      renderWithProviders(
        <ReceiveScreen account={mockMultisigAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(sendMessage).not.toHaveBeenCalledWith(
          expect.objectContaining({
            type: MessageType.GENERATE_ADDRESS,
          })
        );
      });
    });

    it('handles auto-generate address error gracefully', async () => {
      jest.spyOn(console, 'error').mockImplementation(() => {});
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: new Error('Failed to generate'),
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      // Advance timers to handle any setTimeout calls
      jest.advanceTimersByTime(5000);
      await Promise.resolve();

      // Should not show privacy banner on error
      expect(screen.queryByText(/Fresh Address Generated/i)).not.toBeInTheDocument();
    });
  });

  describe('Copy Address Functionality', () => {
    it('copies address to clipboard when copy button clicked', async () => {
      // Use real timers for this test
      jest.useRealTimers();

      const user = userEvent.setup({ delay: null });

      // Mock clipboard for this test (since jest.clearAllMocks might have cleared it)
      const writeTextMock = jest.fn().mockResolvedValue(undefined);
      Object.defineProperty(navigator, 'clipboard', {
        value: { writeText: writeTextMock },
        writable: true,
        configurable: true,
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qnew123',
          derivationPath: "m/84'/1'/0'/0/2",
          index: 2,
          isChange: false,
          used: false,
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      // Wait for component to fully render
      await waitFor(() => {
        expect(screen.getByText(/Your Bitcoin Address/i)).toBeInTheDocument();
      }, { timeout: 3000 });

      const copyButton = screen.getByRole('button', { name: /Copy Address/i });
      await user.click(copyButton);

      // Should have copied address to clipboard
      expect(writeTextMock).toHaveBeenCalled();

      // Restore fake timers
      jest.useFakeTimers();
    });

    it('shows "Copied!" feedback after copying', async () => {
      const user = userEvent.setup({ delay: null });
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      const copyButton = await screen.findByRole('button', { name: /Copy Address/i });
      await user.click(copyButton);

      expect(await screen.findByText('Copied!')).toBeInTheDocument();
    });

    it('resets "Copied!" feedback after 2 seconds', async () => {
      const user = userEvent.setup({ delay: null });
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      const copyButton = await screen.findByRole('button', { name: /Copy Address/i });
      await user.click(copyButton);

      expect(await screen.findByText('Copied!')).toBeInTheDocument();

      // Fast-forward 2 seconds
      jest.advanceTimersByTime(2000);

      await waitFor(() => {
        expect(screen.queryByText('Copied!')).not.toBeInTheDocument();
        expect(screen.getByText('Copy Address')).toBeInTheDocument();
      });
    });

    it('handles clipboard copy error gracefully', async () => {
      const user = userEvent.setup({ delay: null });
      jest.spyOn(console, 'error').mockImplementation(() => {});
      clipboard.writeText.mockRejectedValue(new Error('Clipboard error'));

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      const copyButton = await screen.findByRole('button', { name: /Copy Address/i });
      await user.click(copyButton);

      // Advance timers to allow promise to settle
      jest.advanceTimersByTime(100);
      await Promise.resolve();

      // Should not show "Copied!" on error
      expect(screen.queryByText('Copied!')).not.toBeInTheDocument();
    });
  });

  describe('QR Code Generation', () => {
    it('displays QR code error when generation fails', async () => {
      (QRCode.toCanvas as jest.Mock).mockImplementation((canvas, text, options, callback) => {
        if (callback) {
          callback(new Error('QR generation failed'));
        }
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(screen.getByText('Failed to generate QR code')).toBeInTheDocument();
      });
    });

    it('regenerates QR code when address changes', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      const { rerender } = renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(QRCode.toCanvas).toHaveBeenCalledTimes(1);
      });

      // Update account with new address
      const updatedAccount = createMockAccount({
        ...mockAccount,
        addresses: [
          ...mockAccount.addresses,
          createMockAddress({
            address: 'tb1qnewaddress123',
            index: 2,
            isChange: false,
          }),
        ],
      });

      rerender(<ReceiveScreen account={updatedAccount} onBack={mockOnBack} />);

      await waitFor(() => {
        expect(QRCode.toCanvas).toHaveBeenCalledWith(
          expect.any(Object),
          'tb1qnewaddress123',
          expect.any(Object),
          expect.any(Function)
        );
      });
    });
  });

  describe('Multisig Account Display', () => {
    it('shows multisig badge and info', async () => {
      renderWithProviders(
        <ReceiveScreen account={mockMultisigAccount} onBack={mockOnBack} />
      );

      expect(await screen.findByText('Multisig Account')).toBeInTheDocument();
      const badges = screen.getAllByText(/2-of-3/i);
      expect(badges.length).toBeGreaterThan(0);
    });

    it('displays multisig description', async () => {
      renderWithProviders(
        <ReceiveScreen account={mockMultisigAccount} onBack={mockOnBack} />
      );

      expect(
        await screen.findByText(/Funds sent to this address will require.*2.*signatures to spend/i)
      ).toBeInTheDocument();
    });

    it('shows co-signer list for multisig', async () => {
      renderWithProviders(
        <ReceiveScreen account={mockMultisigAccount} onBack={mockOnBack} />
      );

      // Check if co-signer names are displayed (implementation dependent)
      // This test assumes CoSignerList component is used
      expect(await screen.findByText('Multisig Account')).toBeInTheDocument();
    });

    it('displays derivation path for multisig address', async () => {
      renderWithProviders(
        <ReceiveScreen account={mockMultisigAccount} onBack={mockOnBack} />
      );

      const derivationPaths = await screen.findAllByText(/Derivation Path/i);
      expect(derivationPaths.length).toBeGreaterThan(0);
      const paths = screen.getAllByText(/m\/48'/i);
      expect(paths.length).toBeGreaterThan(0);
    });
  });

  describe('Address List Display', () => {
    it('shows all receiving addresses when multiple exist', async () => {
      const accountWithMultipleAddresses = createMockAccount({
        addresses: [
          createMockAddress({ address: 'tb1qaddr0', index: 0, isChange: false }),
          createMockAddress({ address: 'tb1qaddr1', index: 1, isChange: false }),
          createMockAddress({ address: 'tb1qaddr2', index: 2, isChange: false }),
        ],
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithMultipleAddresses} onBack={mockOnBack} />
      );

      expect(await screen.findByText('All Receiving Addresses')).toBeInTheDocument();
      const addr0 = screen.getAllByText('tb1qaddr0');
      const addr1 = screen.getAllByText('tb1qaddr1');
      const addr2 = screen.getAllByText('tb1qaddr2');
      expect(addr0.length).toBeGreaterThan(0);
      expect(addr1.length).toBeGreaterThan(0);
      expect(addr2.length).toBeGreaterThan(0);
    });

    it('marks current address in address list', async () => {
      const accountWithMultipleAddresses = createMockAccount({
        addresses: [
          createMockAddress({ address: 'tb1qaddr0', index: 0, isChange: false }),
          createMockAddress({ address: 'tb1qaddr1', index: 1, isChange: false }),
        ],
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithMultipleAddresses} onBack={mockOnBack} />
      );

      expect(await screen.findByText('(Current)')).toBeInTheDocument();
    });

    it('shows privacy badges for used vs unused addresses', async () => {
      const accountWithUsedAddresses = createMockAccount({
        addresses: [
          createMockAddress({ address: 'tb1qused0', index: 0, isChange: false, used: true }),
          createMockAddress({ address: 'tb1qfresh1', index: 1, isChange: false, used: false }),
        ],
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithUsedAddresses} onBack={mockOnBack} />
      );

      expect(await screen.findByText(/Previously used/i)).toBeInTheDocument();
      const freshBadges = screen.getAllByText(/Fresh/i);
      expect(freshBadges.length).toBeGreaterThan(0);
    });

    it('shows privacy warning for reused addresses', async () => {
      const accountWithUsedAddress = createMockAccount({
        addresses: [
          createMockAddress({ address: 'tb1qused0', index: 0, isChange: false, used: true }),
          createMockAddress({ address: 'tb1qfresh1', index: 1, isChange: false, used: false }),
        ],
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithUsedAddress} onBack={mockOnBack} />
      );

      expect(
        await screen.findByText(/Reusing addresses reduces privacy/i)
      ).toBeInTheDocument();
    });

    it('does not show address list when only one address', async () => {
      const accountWithOneAddress = createMockAccount({
        addresses: [
          createMockAddress({ address: 'tb1qaddr0', index: 0, isChange: false }),
        ],
      });

      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithOneAddress} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(screen.queryByText('All Receiving Addresses')).not.toBeInTheDocument();
      });
    });
  });

  describe('Empty State', () => {
    it('shows empty state when no addresses available', async () => {
      const accountWithNoAddresses = createMockAccount({
        addresses: [],
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithNoAddresses} onBack={mockOnBack} />
      );

      await waitFor(() => {
        expect(screen.getByText('No receiving address available')).toBeInTheDocument();
      });
      expect(screen.getByText('Generate an address to receive Bitcoin')).toBeInTheDocument();
    });

    it('does not show QR code when no address', () => {
      const accountWithNoAddresses = createMockAccount({
        addresses: [],
      });

      renderWithProviders(
        <ReceiveScreen account={accountWithNoAddresses} onBack={mockOnBack} />
      );

      expect(screen.queryByRole('canvas')).not.toBeInTheDocument();
    });
  });

  describe('Back Navigation', () => {
    it('calls onBack when back button clicked in tab mode', async () => {
      const user = userEvent.setup({ delay: null });
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={false} />
      );

      const backButton = await screen.findByRole('button', { name: /Back/i });
      await user.click(backButton);

      expect(mockOnBack).toHaveBeenCalledTimes(1);
    });

    it('does not show back button in modal mode', () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={true} />
      );

      expect(screen.queryByRole('button', { name: /Back/i })).not.toBeInTheDocument();
    });
  });

  describe('Privacy Features', () => {
    it('dismisses privacy banner when dismiss button clicked', async () => {
      // Use real timers for this test
      jest.useRealTimers();

      const user = userEvent.setup({ delay: null });
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: {
          address: 'tb1qnew123',
          derivationPath: "m/84'/1'/0'/0/2",
          index: 2,
          isChange: false,
          used: false,
        },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} />
      );

      expect(await screen.findByText(/Fresh Address Generated/i, {}, { timeout: 3000 })).toBeInTheDocument();

      const dismissButton = screen.getByRole('button', { name: /dismiss/i });
      await user.click(dismissButton);

      await waitFor(() => {
        expect(screen.queryByText(/Fresh Address Generated/i)).not.toBeInTheDocument();
      });

      // Restore fake timers for other tests
      jest.useFakeTimers();
    });
  });

  describe('Accessibility', () => {
    it('has accessible button labels', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={false} />
      );

      expect(await screen.findByRole('button', { name: /Copy Address/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /Back/i })).toBeInTheDocument();
    });

    it('has proper heading hierarchy', async () => {
      mockChromeSendMessageAsync({
        [MessageType.GENERATE_ADDRESS]: { address: 'tb1qnew123' },
      });

      renderWithProviders(
        <ReceiveScreen account={mockAccount} onBack={mockOnBack} isModal={false} />
      );

      const heading = await screen.findByRole('heading', { name: /Receive Bitcoin/i });
      expect(heading).toBeInTheDocument();
      expect(heading.tagName).toBe('H1');
    });
  });
});
