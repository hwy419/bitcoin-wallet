/**
 * BackupManager Tests
 *
 * Comprehensive test suite for wallet backup and restore functionality.
 * Tests cover the CRITICAL requirement that all wallet data, especially
 * address indices, are preserved exactly during backup/restore operations.
 *
 * CRITICAL: Loss of address indices leads to LOSS OF FUNDS due to BIP44 gap limit.
 *
 * Test Coverage:
 * - Export wallet to encrypted backup file
 * - Import wallet from encrypted backup file
 * - Round-trip export/import verification
 * - Address indices preservation (CRITICAL)
 * - Multi-account wallets
 * - Imported private keys
 * - Multisig wallets with PSBTs
 * - Network validation
 * - Checksum verification
 * - Password validation
 * - Error handling
 *
 * @jest-environment node
 */

import { webcrypto } from 'crypto';
import { BackupManager } from '../BackupManager';
import { WalletStorage } from '../WalletStorage';
import { ContactsStorage } from '../ContactsStorage';
import { CryptoUtils } from '../CryptoUtils';
import type {
  StoredWallet,
  StoredWalletV2,
  WalletAccount,
  Account,
  MultisigAccount,
  Contact,
  PendingMultisigTx,
  ImportedKeyData,
  EncryptedBackupFile,
} from '../../../shared/types';
import {
  TEST_MNEMONIC_12,
  TEST_PASSWORD_STRONG,
  TEST_PASSWORD_WEAK,
} from '../../../__tests__/utils/testConstants';
import {
  createMockAccount,
  createMockAccounts,
  createMockAddresses,
} from '../../../__tests__/utils/testFactories';
import { storageMock } from '../../../__tests__/__mocks__/chrome';

// Ensure crypto.subtle is available
if (!global.crypto) {
  (global as any).crypto = webcrypto;
}
if (!global.crypto.subtle) {
  (global as any).crypto.subtle = webcrypto.subtle;
}

// Mock chrome.runtime.getManifest
(global as any).chrome = {
  ...(global as any).chrome,
  runtime: {
    ...(global as any).chrome?.runtime,
    getManifest: () => ({ version: '0.10.0' }),
  },
};

describe('BackupManager', () => {
  const WALLET_PASSWORD = TEST_PASSWORD_STRONG;
  const BACKUP_PASSWORD = 'BackupPassword123!@#$%';
  const BACKUP_PASSWORD_TOO_SHORT = 'short';

  beforeEach(async () => {
    jest.clearAllMocks();
    (global as any).__restoreOriginalCrypto();
    await storageMock.clear();
  });

  // ===========================================================================
  // Helper Functions
  // ===========================================================================

  /**
   * Create a test wallet with encryption
   */
  async function createTestWallet(
    accounts: WalletAccount[] = [],
    importedKeys?: { [accountIndex: number]: ImportedKeyData },
    pendingMultisigTxs?: PendingMultisigTx[]
  ): Promise<StoredWallet> {
    const encryptionResult = await CryptoUtils.encrypt(TEST_MNEMONIC_12, WALLET_PASSWORD);

    const wallet: StoredWalletV2 = {
      version: 2,
      encryptedSeed: encryptionResult.encryptedData,
      salt: encryptionResult.salt,
      iv: encryptionResult.iv,
      accounts: accounts.length > 0 ? accounts : [
        createMockAccount({
          index: 0,
          name: 'Account 1',
          addressType: 'native-segwit',
          externalIndex: 5,
          internalIndex: 2,
          addresses: createMockAddresses(7), // 5 external + 2 internal
        }),
      ],
      settings: {
        autoLockMinutes: 15,
        network: 'testnet',
      },
      pendingMultisigTxs: pendingMultisigTxs || [],
      importedKeys: importedKeys,
    };

    await storageMock.set({ wallet });
    return wallet;
  }

  /**
   * Create test contacts using addresses from the codebase that are known to work
   */
  async function createTestContacts(count: number = 2): Promise<Contact[]> {
    const wallet = await WalletStorage.getWallet();
    const contactsData = {
      version: 2,
      contacts: [],
      salt: wallet.salt,
    };
    await storageMock.set({ contacts: contactsData });

    // Use addresses that are actually generated by the wallet
    // These are from mock addresses used elsewhere in tests
    const testAddresses = createMockAddresses(count > 5 ? count : 5).map(addr => addr.address);

    const contacts: Contact[] = [];
    for (let i = 0; i < count && i < testAddresses.length; i++) {
      const contact = await ContactsStorage.addContact(
        {
          name: `Contact ${i + 1}`,
          address: testAddresses[i],
          category: 'Test',
          notes: `Test contact ${i + 1}`,
        },
        WALLET_PASSWORD,
        'testnet'
      );
      contacts.push(contact);
    }

    return contacts;
  }

  /**
   * Create a multisig account for testing
   */
  function createMockMultisigAccount(index: number = 0): MultisigAccount {
    return {
      accountType: 'multisig',
      index,
      name: `Multisig Account ${index + 1}`,
      multisigConfig: '2-of-3',
      addressType: 'p2wsh',
      cosigners: [
        {
          name: 'Self',
          xpub: 'tpubD6NzVbkrYhZ4...',
          fingerprint: '12345678',
          derivationPath: "m/48'/1'/0'/2'",
          isSelf: true,
        },
        {
          name: 'Cosigner 1',
          xpub: 'tpubD6NzVbkrYhZ5...',
          fingerprint: '23456789',
          derivationPath: "m/48'/1'/0'/2'",
          isSelf: false,
        },
        {
          name: 'Cosigner 2',
          xpub: 'tpubD6NzVbkrYhZ6...',
          fingerprint: '34567890',
          derivationPath: "m/48'/1'/0'/2'",
          isSelf: false,
        },
      ],
      externalIndex: 3,
      internalIndex: 1,
      addresses: createMockAddresses(4) as any[],
    };
  }

  /**
   * Create a mock pending PSBT
   */
  function createMockPendingPSBT(): PendingMultisigTx {
    return {
      id: crypto.randomUUID(),
      accountId: 0,
      psbtBase64: 'cHNidP8BAHECAAAAAQQoZGF0YQAA...',
      created: Date.now(),
      expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days
      multisigConfig: '2-of-3',
      signaturesCollected: 1,
      signaturesRequired: 2,
      signatureStatus: {
        '12345678': {
          signed: true,
          timestamp: Date.now(),
          cosignerName: 'Self',
        },
        '23456789': {
          signed: false,
          cosignerName: 'Cosigner 1',
        },
        '34567890': {
          signed: false,
          cosignerName: 'Cosigner 2',
        },
      },
      metadata: {
        amount: 100000,
        recipient: 'tb1qtest123abc456',
        fee: 1000,
      },
    };
  }

  // ===========================================================================
  // Export Wallet Tests
  // ===========================================================================

  describe('exportWallet', () => {
    it('should export wallet to encrypted backup file', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Verify backup file structure
      expect(backupFile).toBeDefined();
      expect(backupFile.header).toBeDefined();
      expect(backupFile.header.magicBytes).toBe('BTCWALLET');
      expect(backupFile.header.version).toBe(1);
      expect(backupFile.header.network).toBe('testnet');
      expect(backupFile.header.appVersion).toBe('0.10.0');
      expect(backupFile.header.created).toBeGreaterThan(0);

      // Verify encryption metadata
      expect(backupFile.encryption).toBeDefined();
      expect(backupFile.encryption.algorithm).toBe('AES-256-GCM');
      expect(backupFile.encryption.pbkdf2Iterations).toBe(600000);
      expect(backupFile.encryption.salt).toBeDefined();
      expect(backupFile.encryption.iv).toBeDefined();

      // Verify encrypted data
      expect(backupFile.encryptedData).toBeDefined();
      expect(typeof backupFile.encryptedData).toBe('string');
      expect(backupFile.encryptedData.length).toBeGreaterThan(0);

      // Verify checksum
      expect(backupFile.checksum).toBeDefined();
      expect(backupFile.checksum.algorithm).toBe('SHA-256');
      expect(backupFile.checksum.hash).toBeDefined();
      expect(backupFile.checksum.hash.length).toBe(64); // SHA-256 hex is 64 chars
    });

    it('should include all account data in backup', async () => {
      const accounts = createMockAccounts(3).map((acc, i) => ({
        ...acc,
        externalIndex: i * 2 + 1,
        internalIndex: i + 1,
        addresses: createMockAddresses((i + 1) * 3),
      }));

      await createTestWallet(accounts);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile).toBeDefined();
      expect(backupFile.encryptedData.length).toBeGreaterThan(0);
    });

    it('should include contacts in backup', async () => {
      await createTestWallet();
      await createTestContacts(3);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile).toBeDefined();
      // Encrypted data should be larger with contacts
      expect(backupFile.encryptedData.length).toBeGreaterThan(100);
    });

    it('should include imported keys in backup', async () => {
      const importedKeyData: ImportedKeyData = {
        encryptedData: 'encrypted_wif_data',
        salt: 'salt123',
        iv: 'iv123',
        type: 'private-key',
      };

      await createTestWallet([], { 0: importedKeyData });

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile).toBeDefined();
    });

    it('should include multisig accounts and PSBTs in backup', async () => {
      const multisigAccount = createMockMultisigAccount(0);
      const pendingPSBT = createMockPendingPSBT();

      await createTestWallet([multisigAccount], undefined, [pendingPSBT]);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile).toBeDefined();
    });

    it('should reject if wallet password is incorrect', async () => {
      await createTestWallet();

      await expect(
        BackupManager.exportWallet('wrong_password', BACKUP_PASSWORD)
      ).rejects.toThrow('Incorrect wallet password');
    });

    it('should reject if backup password is same as wallet password', async () => {
      await createTestWallet();

      await expect(
        BackupManager.exportWallet(WALLET_PASSWORD, WALLET_PASSWORD)
      ).rejects.toThrow('Backup password must be different from wallet password');
    });

    it('should reject if backup password is too short', async () => {
      await createTestWallet();

      await expect(
        BackupManager.exportWallet(WALLET_PASSWORD, BACKUP_PASSWORD_TOO_SHORT)
      ).rejects.toThrow('Backup password must be at least 12 characters');
    });

    it('should reject if wallet password is empty', async () => {
      await createTestWallet();

      await expect(
        BackupManager.exportWallet('', BACKUP_PASSWORD)
      ).rejects.toThrow('Wallet password cannot be empty');
    });

    it('should reject if backup password is empty', async () => {
      await createTestWallet();

      await expect(
        BackupManager.exportWallet(WALLET_PASSWORD, '')
      ).rejects.toThrow('Backup password cannot be empty');
    });

    it('should handle wallet with no contacts gracefully', async () => {
      await createTestWallet();
      // No contacts created

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile).toBeDefined();
      expect(backupFile.encryptedData).toBeDefined();
    });

    it('should call progress callback during export', async () => {
      await createTestWallet();

      const progressCallback = jest.fn();
      await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD,
        progressCallback
      );

      expect(progressCallback).toHaveBeenCalled();
      expect(progressCallback.mock.calls[0][0]).toBe(10); // First call at 10%
      expect(progressCallback.mock.calls[progressCallback.mock.calls.length - 1][0]).toBe(100);
    });
  });

  // ===========================================================================
  // Import Wallet Tests
  // ===========================================================================

  describe('importWallet', () => {
    it('should import wallet from backup file', async () => {
      await createTestWallet();
      const contacts = await createTestContacts(2);

      // Export
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Clear storage
      await storageMock.clear();

      // Import
      const result = await BackupManager.importWallet(
        backupFile,
        BACKUP_PASSWORD
      );

      expect(result.success).toBe(true);
      expect(result.accountCount).toBe(1);
      expect(result.contactCount).toBe(2);
      expect(result.network).toBe('testnet');
      expect(result.hasMultisig).toBe(false);
      expect(result.hasImportedKeys).toBe(false);

      // Verify wallet was restored
      const restoredWallet = await WalletStorage.getWallet();
      expect(restoredWallet).toBeDefined();
      expect(restoredWallet.accounts.length).toBe(1);

      // Verify contacts were restored
      const restoredContacts = await ContactsStorage.getContacts(WALLET_PASSWORD);
      expect(restoredContacts.length).toBe(2);
    });

    it('should restore multisig accounts with PSBTs', async () => {
      const multisigAccount = createMockMultisigAccount(0);
      const pendingPSBT = createMockPendingPSBT();

      await createTestWallet([multisigAccount], undefined, [pendingPSBT]);

      // Export
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Clear storage
      await storageMock.clear();

      // Import
      const result = await BackupManager.importWallet(
        backupFile,
        BACKUP_PASSWORD
      );

      expect(result.success).toBe(true);
      expect(result.hasMultisig).toBe(true);

      // Verify multisig account restored
      const restoredWallet = await WalletStorage.getWallet();
      expect(restoredWallet.version).toBe(2);

      const walletV2 = restoredWallet as StoredWalletV2;
      expect(walletV2.accounts.length).toBe(1);
      expect(walletV2.accounts[0].accountType).toBe('multisig');
      expect(walletV2.pendingMultisigTxs.length).toBe(1);
    });

    it('should restore imported keys', async () => {
      const importedKeyData: ImportedKeyData = {
        encryptedData: 'encrypted_wif_data',
        salt: 'salt123',
        iv: 'iv123',
        type: 'private-key',
      };

      await createTestWallet([], { 0: importedKeyData });

      // Export
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Clear storage
      await storageMock.clear();

      // Import
      const result = await BackupManager.importWallet(
        backupFile,
        BACKUP_PASSWORD
      );

      expect(result.success).toBe(true);
      expect(result.hasImportedKeys).toBe(true);

      // Verify imported keys restored
      const restoredWallet = await WalletStorage.getWallet();
      const walletV2 = restoredWallet as StoredWalletV2;
      expect(walletV2.importedKeys).toBeDefined();
      expect(walletV2.importedKeys![0]).toEqual(importedKeyData);
    });

    it('should reject if backup password is incorrect', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await expect(
        BackupManager.importWallet(backupFile, 'wrong_backup_password')
      ).rejects.toThrow();
    });

    it('should reject if checksum is invalid', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Corrupt checksum
      backupFile.checksum.hash = 'invalid_checksum_123';

      await expect(
        BackupManager.importWallet(backupFile, BACKUP_PASSWORD)
      ).rejects.toThrow('Checksum mismatch');
    });

    it('should reject if backup file structure is invalid', async () => {
      const invalidBackupFile = {
        header: {},
        encryption: {},
        encryptedData: '',
        checksum: {},
      } as any;

      await expect(
        BackupManager.importWallet(invalidBackupFile, BACKUP_PASSWORD)
      ).rejects.toThrow();
    });

    it('should replace existing wallet during import', async () => {
      // Create initial wallet
      await createTestWallet([
        createMockAccount({ index: 0, name: 'Old Account' }),
      ]);

      // Create backup of different wallet
      await storageMock.clear();
      await createTestWallet([
        createMockAccount({ index: 0, name: 'New Account' }),
      ]);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Restore old wallet
      await storageMock.clear();
      await createTestWallet([
        createMockAccount({ index: 0, name: 'Old Account' }),
      ]);

      // Import new wallet (should replace)
      const result = await BackupManager.importWallet(
        backupFile,
        BACKUP_PASSWORD
      );

      expect(result.success).toBe(true);

      const restoredWallet = await WalletStorage.getWallet();
      expect(restoredWallet.accounts[0].name).toBe('New Account');
    });

    it('should call progress callback during import', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();

      const progressCallback = jest.fn();
      await BackupManager.importWallet(
        backupFile,
        BACKUP_PASSWORD,
        progressCallback
      );

      expect(progressCallback).toHaveBeenCalled();
      expect(progressCallback.mock.calls[0][0]).toBeGreaterThanOrEqual(5);
      expect(progressCallback.mock.calls[progressCallback.mock.calls.length - 1][0]).toBe(100);
    });
  });

  // ===========================================================================
  // CRITICAL: Round-Trip Address Indices Tests
  // ===========================================================================

  describe('Round-trip address indices preservation (CRITICAL)', () => {
    it('should preserve exact externalIndex and internalIndex', async () => {
      const account = createMockAccount({
        index: 0,
        name: 'Test Account',
        externalIndex: 42,
        internalIndex: 17,
        addresses: createMockAddresses(59), // 42 external + 17 internal
      });

      await createTestWallet([account]);

      // Export
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Clear and import
      await storageMock.clear();
      await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      // Verify indices are EXACTLY preserved
      const restoredWallet = await WalletStorage.getWallet();
      const restoredAccount = restoredWallet.accounts[0] as Account;

      expect(restoredAccount.externalIndex).toBe(42);
      expect(restoredAccount.internalIndex).toBe(17);
    });

    it('should preserve complete addresses array with used flags', async () => {
      const addresses = createMockAddresses(10).map((addr, i) => ({
        ...addr,
        used: i < 5, // First 5 are used
      }));

      const account = createMockAccount({
        index: 0,
        externalIndex: 10,
        internalIndex: 0,
        addresses,
      });

      await createTestWallet([account]);

      // Export and import
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      // Verify addresses array is preserved
      const restoredWallet = await WalletStorage.getWallet();
      const restoredAccount = restoredWallet.accounts[0] as Account;

      expect(restoredAccount.addresses.length).toBe(10);

      // Verify used flags preserved
      restoredAccount.addresses.forEach((addr, i) => {
        expect(addr.used).toBe(i < 5);
        expect(addr.index).toBe(i);
      });
    });

    it('should preserve indices for multiple accounts', async () => {
      const accounts: Account[] = [
        createMockAccount({
          index: 0,
          name: 'Account 1',
          externalIndex: 15,
          internalIndex: 8,
          addresses: createMockAddresses(23),
        }),
        createMockAccount({
          index: 1,
          name: 'Account 2',
          externalIndex: 30,
          internalIndex: 12,
          addresses: createMockAddresses(42),
        }),
        createMockAccount({
          index: 2,
          name: 'Account 3',
          externalIndex: 50,
          internalIndex: 25,
          addresses: createMockAddresses(75),
        }),
      ];

      await createTestWallet(accounts);

      // Export and import
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      // Verify all accounts have correct indices
      const restoredWallet = await WalletStorage.getWallet();
      expect(restoredWallet.accounts.length).toBe(3);

      const expectedIndices = [
        { external: 15, internal: 8 },
        { external: 30, internal: 12 },
        { external: 50, internal: 25 },
      ];

      restoredWallet.accounts.forEach((account, i) => {
        const acc = account as Account;
        expect(acc.externalIndex).toBe(expectedIndices[i].external);
        expect(acc.internalIndex).toBe(expectedIndices[i].internal);
      });
    });

    it('should preserve multisig account indices', async () => {
      const multisigAccount = createMockMultisigAccount(0);
      multisigAccount.externalIndex = 25;
      multisigAccount.internalIndex = 10;

      await createTestWallet([multisigAccount]);

      // Export and import
      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      // Verify multisig indices preserved
      const restoredWallet = await WalletStorage.getWallet();
      const restoredAccount = restoredWallet.accounts[0] as MultisigAccount;

      expect(restoredAccount.externalIndex).toBe(25);
      expect(restoredAccount.internalIndex).toBe(10);
    });
  });

  // ===========================================================================
  // Validate Backup File Tests
  // ===========================================================================

  describe('validateBackupFile', () => {
    it('should validate correct backup file structure', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(true);
      expect(validation.version).toBe(1);
      expect(validation.network).toBe('testnet');
      expect(validation.created).toBeGreaterThan(0);
      expect(validation.error).toBeUndefined();
    });

    it('should reject file with wrong magic bytes', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      backupFile.header.magicBytes = 'WRONGBYTES' as any;

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Invalid file type');
    });

    it('should reject file with unsupported version', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      backupFile.header.version = 99;

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Backup version 99 is not supported');
    });

    it('should reject file with invalid network', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      backupFile.header.network = 'invalid' as any;

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Invalid network');
    });

    it('should reject file missing encryption metadata', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      delete (backupFile as any).encryption;

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Invalid encryption metadata');
    });

    it('should reject file missing checksum', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      delete (backupFile as any).checksum;

      const validation = await BackupManager.validateBackupFile(backupFile);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Missing checksum');
    });

    it('should reject non-object input', async () => {
      const validation = await BackupManager.validateBackupFile('not an object' as any);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Invalid file format');
    });

    it('should reject null input', async () => {
      const validation = await BackupManager.validateBackupFile(null as any);

      expect(validation.valid).toBe(false);
      expect(validation.error).toContain('Invalid file format');
    });
  });

  // ===========================================================================
  // Network Validation Tests
  // ===========================================================================

  describe('Network validation', () => {
    it('should detect network mismatch in backup file', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Corrupt network in header
      backupFile.header.network = 'mainnet';

      await expect(
        BackupManager.importWallet(backupFile, BACKUP_PASSWORD)
      ).rejects.toThrow('Network mismatch');
    });

    it('should preserve network setting during round-trip', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      const restoredWallet = await WalletStorage.getWallet();
      expect(restoredWallet.settings.network).toBe('testnet');
    });
  });

  // ===========================================================================
  // Edge Cases and Error Handling
  // ===========================================================================

  describe('Edge cases', () => {
    it('should handle wallet with single default account', async () => {
      // Wallets always have at least one account
      await createTestWallet([]);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      const result = await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      expect(result.success).toBe(true);
      expect(result.accountCount).toBe(1); // Default account created
    });

    it('should handle wallet with maximum accounts', async () => {
      const accounts = createMockAccounts(10); // Reasonable max

      await createTestWallet(accounts);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      const result = await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      expect(result.success).toBe(true);
      expect(result.accountCount).toBe(10);
    });

    it('should handle wallet with no contacts', async () => {
      await createTestWallet();
      // No contacts

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      const result = await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      expect(result.success).toBe(true);
      expect(result.contactCount).toBe(0);
    });

    it('should handle wallet with many contacts', async () => {
      await createTestWallet();
      // Use 5 contacts (limited by valid testnet addresses available)
      await createTestContacts(5);

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      await storageMock.clear();
      const result = await BackupManager.importWallet(backupFile, BACKUP_PASSWORD);

      expect(result.success).toBe(true);
      expect(result.contactCount).toBe(5);
    });
  });

  // ===========================================================================
  // Security Tests
  // ===========================================================================

  describe('Security', () => {
    it('should use different salt for each backup', async () => {
      await createTestWallet();

      const backup1 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      const backup2 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backup1.encryption.salt).not.toBe(backup2.encryption.salt);
    });

    it('should use different IV for each backup', async () => {
      await createTestWallet();

      const backup1 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      const backup2 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backup1.encryption.iv).not.toBe(backup2.encryption.iv);
    });

    it('should produce different encrypted data for same wallet', async () => {
      await createTestWallet();

      const backup1 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      const backup2 = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      // Due to different salt/IV, encrypted data should be different
      expect(backup1.encryptedData).not.toBe(backup2.encryptedData);
    });

    it('should use 600K PBKDF2 iterations for backup encryption', async () => {
      await createTestWallet();

      const backupFile = await BackupManager.exportWallet(
        WALLET_PASSWORD,
        BACKUP_PASSWORD
      );

      expect(backupFile.encryption.pbkdf2Iterations).toBe(600000);
    });
  });
});
